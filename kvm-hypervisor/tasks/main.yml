- name: ensure kvm is installed and started
  service:
    name: libvirtd
    state: started
    enabled: yes
  register: libvirtd

- name: wait for libvirtd to start up
  pause:
    seconds: 30
  when: libvirtd.changed

# - name: ensure genisoimage is installed
#   yum:
#     name: genisoimage
#     state: present

- name: clean up any old temporary workspaces
  file:
    name: "{{ kvm_host.tmp_workspace }}"
    state: absent
  ignore_errors: true

- name: create workspace folder
  file:
    name: "{{ kvm_host.tmp_workspace }}"
    state: directory

- name: add ssh public key to workspace folder
  copy:
    src: "{{ instance.ssh_key.file_public }}"
    dest: "{{ kvm_host.tmp_workspace }}/ssh_key.pub"

- name: clean up old virtual machines and their artifacts
  include: cleanup.yml
  when: kvm_host.cleanup

- name: Copy over the virtual disk images
  copy:
    src: "{{ kvm_host.disk_image }}"
    dest: "{{ kvm_host.disk_dir }}/{{ item.key }}.qcow2"
  with_dict: "{{ instance.nodes }}"

- name: create data disk
  command: qemu-img create -f qcow2 -o preallocation=metadata {{ kvm_host.disk_dir }}/{{ item.key }}-data.qcow2 {{ item.value.vol_size }}G
  with_dict: "{{ instance.nodes }}"

- name: create temporary folder for host disk customization
  file:
    name: "{{ kvm_host.tmp_workspace }}/{{ item.key }}"
    state: directory
  with_dict: "{{ instance.nodes }}"

- name: create the metadata ISO directory
  file:
    name: "{{ kvm_host.tmp_workspace }}/{{ item.key }}/metadata"
    state: directory
  with_dict: "{{ instance.nodes }}"

- name: create meta-data files for cloud-init
  template:
    src: meta-data.j2
    dest: "{{ kvm_host.tmp_workspace }}/{{ item.key }}/metadata/meta-data"
  with_dict: "{{ instance.nodes }}"

- name: create user-data files for cloud-init
  template:
    src: user-data.j2
    dest: "{{ kvm_host.tmp_workspace }}/{{ item.key }}/metadata/user-data"
  with_dict: "{{ instance.nodes }}"

- name: create cloud-config ISO image
  command: genisoimage -o {{ kvm_host.tmp_workspace }}/{{ item.key }}-ci.iso -V cidata -r -J {{ kvm_host.tmp_workspace }}/{{ item.key }}/metadata/user-data {{ kvm_host.tmp_workspace }}/{{ item.key }}/metadata/meta-data
  with_dict: "{{ instance.nodes }}"

- name: copy over cloud-init ISOs
  copy:
    src: "{{ kvm_host.tmp_workspace }}/{{ item.key }}-ci.iso"
    dest: "{{ kvm_host.disk_dir }}/{{ item.key }}-ci.iso"
  with_dict: "{{ instance.nodes }}"
  become: yes

- name: Define guest images
  virt:
    name: "{{ item.key }}"
    command: define
    xml: "{{ lookup('template', 'vm.xml') }}"
    uri: qemu:///system
  with_dict: "{{ instance.nodes }}"
  become: yes

- name: remove any static ips from libvirt
  command: virsh net-update {{ kvm_host.network.name }} delete ip-dhcp-host '<host mac="{{ item.value.kvm_params.mac }}" ip="{{ item.value.kvm_params.ip }}"/>' --config --live
  ignore_errors: true
  with_dict: "{{ instance.nodes }}"
  become: yes

- name: add static ip addresses for hosts
  command: virsh net-update {{ kvm_host.network.name }} add ip-dhcp-host '<host mac="{{ item.value.kvm_params.mac }}" ip="{{ item.value.kvm_params.ip }}"/>' --config --live
  with_dict: "{{ instance.nodes }}"
  become: yes

- name: stop libvirt networking
  virt_net:
    command: destroy
    name: "{{ kvm_host.network.name }}"
  become: yes

- name: start libvirt networking
  virt_net:
    command: start
    name: "{{ kvm_host.network.name }}"
  become: yes

- name: Start the new Virtual Machines
  virt:
    name: "{{ item.key }}"
    command: start
    uri: qemu:///system
  with_dict: "{{ instance.nodes }}"
  become: yes

# - name: make sure the known_hosts file exists
#   file:
#     path: "{{ kvm_host.known_hosts_file }}"
#     state: touch

# - name: remove any stale entries for these virtual Machines by hostname
#   shell: "ssh-keygen -R {{ item.key }} -f {{ kvm_host.known_hosts_file}}"
#   with_dict: "{{ instance.nodes }}"
#
- name: remove any stale entries for these virtual Machines by ip
  shell: "ssh-keygen -R {{ item.value.kvm_params.ip }} -f {{ kvm_host.known_hosts_file}}"
  with_dict: "{{ instance.nodes }}"

# - name: scan ssh keys by hostname
#   command: "ssh-keyscan {{ item.key }}"
#   register: "{{ item.key }}-host_keys_hostname"
#   with_dict: "{{ instance.nodes }}"
#   changed_when: false
#   delegate_to: localhost
#   become: false
#
# - name: scan ssh keys by IP
#   command: "ssh-keyscan {{ item.value.kvm_params.ip }}"
#   register: "{{ item.key }}-host_keys_ip"
#   with_dict: "{{ instance.nodes }}"
#   changed_when: false
#   delegate_to: localhost
#   become: false
#
# - name: write ssh keys to known_hosts
#   template:
#     src: "ssh-hosts.j2"
#     dest: "{{ kvm_host.known_hosts_file }}"
#
# - name: make sure all vms are running
#   local_action: wait_for host={{ item.key }} port=22 state=started delay=5 timeout=300
#   become: false
#   with_dict: "{{ instance.nodes }}"

- name: create dynamic groups to deploy openshift
  add_host:
    name: "{{ item.key }}"
    ansible_ssh_host: "{{ item.value.kvm_params.ip }}"
    ansible_ssh_port: 22
    groups: "{{ item.value.kvm_params.role }},openshift"
    private_ip: "{{ item.value.kvm_params.ip }}"
    private_hostname: "{{ item.value.kvm_params.hostname }}"
    public_ip: "{{ item.value.kvm_params.ip }}"
    public_hostname: "{{ item.value.kvm_params.hostname }}"
  with_dict: "{{ instance.nodes }}"

- name: wait a few seconds for everything to boot
  pause:
    seconds: 20
